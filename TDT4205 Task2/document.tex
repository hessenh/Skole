%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{article}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\hypersetup{
    %bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={TDT4205 Compilers - Exercise 2 - hvatum},    % title
    pdfauthor={Stian Hvatum},     % author
    pdfsubject={TDT4205 Compilers},   % subject of the document
    pdfcreator={Stian Hvatum},   % creator of the document
    pdfproducer={Stian Hvatum}, % producer of the document
    pdfnewwindow=true,      % links in new window
    colorlinks,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\lstset{ %
  literate= {+}{{$+$}}1 {*}{{$*$}}1 {=}{{$\gets$}}1 
            {<=}{{$\leq$}}1 {>=}{{$\geq$}}1 {!=}{{$\neq$}}1 
            {==}{{$\equiv$}}1 {=>}{{$\leadsto$}}1
            {->}{{$\rightarrow$}}1
}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\input{styles/xml.tex}

\renewcommand{\thesection}{Part \arabic{section}}
\renewcommand{\thesubsection}{Task \arabic{section}.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}

\title{TDT4205 Compilers\\
\Huge Exercise 2}
\author{Stian Hvatum (hvatum)\\MTDT}

\begin{document}
\maketitle

\section{}
\subsection{ -- NOT FINISHED -- }
\begin{tabular}{|c|c|c|}
\hline
NT & FIRST(NT) & FOLLOW(NT) \\
\hline
\hline
E & {i, n, p, m} & {\$, a, m} \\
\hline
S & {i, n, p, m} & {\$, r, a, m}\\
\hline
T & {i, n} & {\$, r, a, m}\\
\hline
F & {i,n} & {\$, r, a, m} \\
\hline
I & {p,m} & {i, n} \\
\hline
\end{tabular}

\subsection{}
\subsubsection{}
A top-down parser creates the parse tree from the root node and down. It has to
predict the right outline of the tree before it can replace nodes with their
productions. This is usualy implemented with guessing and back-tracking. A
bottom-up parser generates the tree from the leaves, and the brances connects where they are supposed to on the way to the top. This is much
easier to get right, and thereby a more powerfull method.

\subsubsection{}
GNU Bison generates a bottom-up parser
\footnote{\url{http://alumni.cs.ucr.edu/~lgao/teaching/bison.html}}.

\subsubsection{}
Writing compilers include a lot of complex both theory and practice. Writing it
by hand is error-prone, and will most likely NOT be better than writing it by
hand. Of course, if you are very well experienced in the field, hand writing may
be an option. Known programs as {\ttfamily bash} and
{\ttfamily Zend\footnote{The PHP-parser}} uses Bison-generated parser by today,
and also GCC used to be backed up by a parser generated by GNU Bison, but
changed in 2000\footnote{\url{http://gcc.gnu.org/ml/gcc/2000-10/msg00573.html}}.

\subsection{}
\subsubsection{}
A shift-reduce parser is a bottom-up parser that keeps a buffer of input and a
stack of grammar symbols. The shift-reduce parser has primarily two internal
functions\footnote{acctually four, if you count ``accept'' and ``error'' as
functions}, shift and reduce. Shift takes one token from the input buffer and
puts it on the stack.
Reduce takes the content on the stack, and tries to reduce it using productions
backwards. For each reduce, one grammatical step is done. Usually, we reduce
until there is no more to reduce, and then we shift, though exceptions may occur
if we use lookahead, and find it better to shift more in order to gain
some better reductions on our input.

\subsubsection{}
Shift-reduce conflicts are conflicts where we must decide wherever the correct
outcome comes from a shift or a reduce, while reduce-reduce conflicts are
conflicts where there are more than one possible reduction on the given input,
and we have to decide wich one is the correct to use.

\begin{figure}[h]
\caption{Example of a shift-reduce conflict}
Given the following grammar:
\begin{lstlisting}
stmt -> if expr then stmt
	   |  if expr then stmt else stmt
	   |  other
\end{lstlisting}
If we now have
\begin{lstlisting}
if expr then stmt
\end{lstlisting}

on the stack, we cannot know if there is best to
reduce as normal, or if we should shift some more to see if there is an \textbf{else} comming, making it an
{\ttfamily if expr then stmt else stmt} instead of a {\ttfamily if expr then
stmt}.
\end{figure}

\begin{figure}[h]
\caption{Example of a reduce-reduce conflict}
Given the following grammar:
\begin{lstlisting}
stmt           -> id ( parameter_list )
stmt           -> expr := expr
parameter_list -> parameter_list , parameter_list
parameter_list -> parameter
parameter      -> id
expr           -> id ( expr_list )
expr           -> id
expr_list      -> expr_list , expr_list
expr_list      -> expr 
\end{lstlisting}
If we now have
\begin{lstlisting}
id ( id
\end{lstlisting}

on the stack, we have multiple allowed reductions. The difference to the last
example, where we got a different valid reduction, is that we now have multiple
valid reductions with the given data allready on the stack. Here, we can reduce
the right most \textbf{id} to either \textit{parameter} or to  \textit{expr}. We
have to know if \textbf{id} is the entire struct is a \textit{stmt} or a
\textit{expr} to decide this correctly. One solution to this problem, is to have
a grammar where this cannot happen, and use a more sophisticated lexer that can
tell the difference between a \textbf{id} that ends up as a \textit{stmt} and a
 \textbf{id} that ends up as an \textit{expr}.
\end{figure}


\end{document}
